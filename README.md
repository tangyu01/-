# -
学习笔记

测试
# 邮箱
账号：13262703997@163.com
账号：18227894110@163.com
密码：tY123456*

# github
账号：tangyu01
密码：tY1234567890*

# 评论

不要一味的满足需求，导致业务方，插入需求导致延期，要反馈调整有反馈，有预期

全力承担做好一件事，提升整体能力，单纯做业务只会跟着别人走，无法建立全面思维，正式，

努力好好学习提升自己，多学点东西，不管是工作还是副业，天道酬勤。

年轻应该要锻炼自己，丰富自己，接受挑战，韧  提高效率
主动参与新技术，分出时间学习技术

对齐主动沟通
项目管理，大项目需要拆的细一点，自我管理提高

对于radar掌控不错，需求多繁琐的情况下，业务要求严厉的现状
沟通和主动保持力度

低代码业务积极主动，低代码业务落地，移动端问题
延期复盘，找措施改善

基本功和关注客户挺好，复盘项目很好，日常迭代偶尔可以，工作投入度高
提高实力

保证总结计划落地，怎么长期坚持，中间遇到问题怎么调整，花一些精力改变现状，才能继续向前走。保证有真正执行，长期践行，验证结果和调整。 做好自测，提高代码稳定性，减少bug

设置正向反馈，每周三件事，底线保证，保证全精力投入


学习微信小程序开发，three.js，3D


热更新，流水线部署优化
  确实是应该从项目出发；真的对已有项目的知识点都吃透了吗？不尽然，很多时候都是在使用了就不去管，或者说符合要求了就没有继续向下学习，要深入学习将项目的能力转为自身的能力。这样才保证持续提升保持竞争力
 关注自己相关的部分，集中精力关注在自身相关的内容，想要确定的问题在一段时间内容集中抛出，拿到结论。  为了进一步优化时间管理和提升综合能力，计划在下一阶段做出以下调整
* 核心开发：75%，主要工作时间，专注于代码编写、调试和优化 - 确保高质量的代码输出和项目进度。
* 会议与协作：15%，精简会议时间，提高会议效率 - 与团队成员保持良好沟通和协作 - 专注于有效和必要的会议。
* 复盘与产品思考：5%，定期进行工作复盘，总结经验教训 - 提高产品思维能力，更好地理解和支持业务需求 - 持续优化工作流程。
* 技术学习：5%，每周固定时间进行新技术学习 - 设定明确的学习目标 - 持续提高技术能力，保持竞争力 注：确保有效利用复盘和学习时间，制定具体计划并严格执行。
 开发：对于开发方面，大的结构方面应该想的很清楚，原则上应该是解耦，可复用，稳定性强，每次开发前的拆任务其实就是思考的过程，平时要注意点；对于专业比自己强的人给出的建议，应该第一时间去尝试适不适合自己，这也是提升能力比较快的一种。

会议方面：每次会议前的记录需要确认的问题，保证会议上拿到结论，对会议中等待确定的问题也记录下来持续根进。

产品思考：对一周做的需求做出总结，需要弄清以下几个问题：1.需求背景，2.解决什么问题，3.在产品建设过程中占据什么样的角色和比重，4.有没有其他的解决方案；如果修的bug：1.bug的原因（是因为体验，还是边界问题，为什么当时没有考虑到）。

学习：持续学习，不管是巩固复习，还是学到新的知识点，每周至少都要有的，哪怕是一个新的知识点，以文档记录；就算平时工作日没有，周日的时候要补上，不可拖到下周。

# 2024.3.7优势：崇尚行动，交付稳定，有责任心，主人翁精神，务实

劣势：对业务的思考不足，所有知识需要深入的学习

解决方向：多转换视角，多问为什么，为什么这么设计->主要在需求评审的时候多思考

机会：参与性能优化方向，应该多思考学习其原理，然后落地实现提升技能；降低生产成本，提高生产效率；

挑战：新的一年业务更加繁忙，需要平衡好工作、学习和生活的节奏；1on1

期望：1、提升自己的规划能力和一些宏观的视角，把细节囊括在内容的，项目的大方向，人力能否支持，感觉有哪些问题，有哪些坑，需要怎么去协调，需要什么支持，从早会来检验，太具体别人不清楚，要宏观一点。2、今年时间多放在总结复盘上，增加事情的掌控感；增加新的视角，需要多增加反馈。

规划：资讯生产方向（编辑、记者、印刷、报亭）->互联网->八卦新闻pgc-ugc，内容生产（去年物料提升的，今年的可能是提升mcplot的使用的占比，lowcode的使用占比），内容消费，先清楚宏观再指导微观怎么去做，性能提升的，跟日常工作相结合，不要所有的事情都放在有空再做，这样大概率就是不会做的呀，摆脱这种想法，更得好需求尝试，物料在今年的是辅助策略，coe的交付有一个很大的改变，

# 2024.4.9

分工：别人问你的是团队内部的事情，就算你不知道，你可以回应，可以帮你下来问下，可以一起拉个群啥的，本人转一下，不要说这不是我负责的，这样就不太好；价值共同体，角色认知有意识去做事，

交付标准加高要求努力，有些质量问题，今年有感知的改动，专注的程度（集中精力投入某一件事），提升效率加大产出结果。

# 2024.5.14（追求完美是没有可行性的）

1.复用，2.专注度：

1、精力，

2、打扰，

3、制定限时任务（比如一个小时专注做一件事，专注做UI，可以先不回消息，当然刚开始有消息就回复，但是超过半小时可以暂时先不回，这个是限时时间可以自己调整的）

总结copilot使用方法（使用次数*代码采纳率）

todo:radar的sso,内存溢出



# 2024.6.19

1.正常工作时场内自己提高效率，提升产出，道的标准是：按照文档做好每一个点按部就班这就是最快的方法，不要每个需求都做一部分，没做完到时候再去做的时候有认识成本的。

2.不断去迭代这件事，技能和方法，上升到标准

3.缓解压力的

乐观去解决（盘一盘那些可以缓，考不了一百先考六十）请求别人帮忙（协调人），哪些问题可以解决的，耗时比较长的找人帮忙的

方法和策略（有地方可和别人商量下，主动和别人商量，让别人感知到你的工作进度的， ）

速度和质量，提高效率的，找一些掣肘的问题解决它，有一些策略去解决它，缓解压力的，怎么去解决它，集中尽力去解决其中一部分，这样才能实打实的解决问题的



# 2024.7.24

1.开会的时候预先看看会议的目的是啥，着重的围绕目的去

2.别顶嘴打好配合对外输出，告警运营能主动去发现，别迟到



# 2024.9.4

1.提前沟通需求，多提提commit；别迟到，调薪2024.11.22

1.基本功，群聊两次握手，响应其他人的消息；

2.参与动态组装



# 2025.1.10

1.价值判断

2.超出预期，提高业务的预期，下线要高于业务的上线，在讨论任务的时候，注重任务合理性，细化任务量（就任务量说话）；不要陷入讨价还价中，这样很容易被人讨厌，尤其是说留buffer这种话，这中应该朝任务的时候解决；跟着产品的发展解决前端开发。个人成长是必须的，需要坚持投入，vue2->vue3；应对未来的变化，跟着时代的浪潮

3.年度目标：故障项目分工，有啥重大的变化，每个月明确目标；准备做哪些事，怎么去应对，这些目标的障碍，动态组装沙箱的



# 2025.2.7

1.故障管理方向人员轮岗

2.新技术的引入，和璇哥讨论有哪些问题，那些地方好，那些地方不好，向移动端使用响应式，还是解决问题

3.辅助璇哥做一些横向的事

讨论：怎么规划今年的事



# 2025.4.2

其他的方向、性能，mrn，大的掣肘问题（每年都解决几个大的），分工问题（），mcp和，先试试大模型；事件管理的计划，移动端，性能，工程化（掣肘的问题）

客服；重点关注的事（质量，使用大模型）

质量问题（先验证，规避）；配置（对工作的投入，工作的态度挺好，要积极地发扬和配和，流程要标准化，成效的问题要复盘是否达到预期）

配合，以工作效率说话重新分配，保持态度主人翁精神，mep，

成效，个人成长，做的事考虑是不是转化率和损耗是不是望预期发展，有效沟通，沟通不能跟着别人走，结束后是不是达成目的，说服别人，完事后需要复盘。思考



# 2025.5.13

性能治理，项目工程化（刑璇的想法，如何去做，为啥会这样想，挑一些影响比较大的事做，发布时长，冷启动），更主动一点去做



# 2025.6.10

ac移动端鉴权问题：

首先确定是否临时方案，

这件事会不会带来风险，如果风险大需要说服别人使用其他方案，不得冒险

# 2025.11.5

 前端汇报关系的变化

人员的变化

长期智能的变化code的冲击（演练的case）尽可能地多用智能（全栈：智能和工作的结合，知识库的建设，多用agent，多计划多智能执行）

智能work，人员变化重新分工（支撑刑璇），运维产品思维（雷雨的对外交流），10月的完成情况，11的需求排列

个人成功，意愿（）*投入（多关注有效工作时长，全勤专注地做一件事）*方法（解决工作的问题，如何调动自己的能力和知识库）

刻意练习* 站到正确的方法（方法很对）*专注地投入

总结事情（判断重要性，是否有结论，是否有跟进人），花了的时间的东西必须要有结论（全身心的投入），听了但是没懂需求主动去问题（实事求是），带入自己思考（应该怎么做，找谁做）；自己相关的听一听，没听懂的主动去问题，带入自己思考怎么做

# 个人总结介绍

## 总结介绍模版

面试官好，我叫xxx，17年毕业于xx大学，毕业后在腾讯工作了2年，主要做QQ应用内的周边商城，负责主页的性能优化和交易链路等；19年来到杭州阿里，主要做淘宝买菜社区团购项目，负责微信域和手淘用增域。
在微信域主要沉淀了小程序动态化方案（解决了小程序不发本情况下也可迭代原生小程序页面的能力）、小程序免登授权方案（在不发版的情况下，打通小程序与webview之间的免登授权）、微信社群分享裂变上的攻防问题（主要通过CDN和ER系统做了动态化域名）等。
在手淘用增域方向上，主要做了策略中心（主要是为了解决C端用户行为实时特征和策略决策问题）、端智能feeds重排：主要是通过端侧行为特征与算法模型推理，对未曝光商品进行打分重排；
在首页性能优化上：主要做了小程序迁H5，在H5优化方案主要从三方面SSR->ESR->NSR三个方向进行优化，从小程序的首开率60%提升到H5首开率90%。
除了以上的业务技术沉淀外，个人也喜欢去倒腾一些新技术，比如近期一直很火的AIGC，chatGPT等，也试着考虑和业务结合尝试（如：买菜助手，结合chatGPT的能力做用户对话框推荐买菜）。


## 为什么

1、当前环境比较动荡，整个业务环境和前景不明朗（社群团购逐渐做变形，微信域不再投资等），业务不好自然机会更少。
2、跳出自己舒适圈，去发现自己的更多可能性，毕业以来一直在做电商类项目，业务上比较单一，从未接触过电商外的项目，想去了解更多互联网场景。

## 讲讲你和普通前端，你的亮点有哪些？

1、善于总结和规划，
2、喜欢钻研新的技术方向，和新的领域。

## 你有什么缺点？

1、性格比较内向，也在逐渐通过不断跟同事交流让自己变得外向些。
2、PM经验少，小范围的技术PM还能owner下来，但是遇到跨部门的大项目合作就会协调不下来，正在努力加强这方面的能力
3、团队分享较少，沟通能力偏弱，多尝试组内分享，提高自己的胆量。

## 最近有关注什么新技术吗？

工程化方面：rust, turbopack等
端智能方面：Python领域学习、TensorFlow.js了解学习
AIGC方向：结合chatGPT能力，出关键词搜索商品，促进用户购买意愿
性能优化方向：ESR，流式渲染方案、FaaS等

## 你是偏向于走各个方向探索还是一直向某个方向研究下去？

## 团队规模，团队规范和开发流程

## 如何带领团队的

1、业务支持和需求整理需求池，了解需求执行进度和存在的风险点，及时协调资源
2、落实开发规范，
3、团队分工：业务划分：基础链路、交易链路、用增、营销等；技术划分：工程化、端智能、搭建等
4、组织例会，技术分享，核心库代码CR
5、代码质量cr



背景：

白屏
cookie 
JWT 不安全，用cookie的更安全

业务数据了解一下，优惠券的核销率

SDK具体做的事情，策略匹配、

端计算：

体积优化

commonjs 导出对象不确定


// 实现Task
const process = new Task(3)
const creator = timer => () => {
    return new Promise(resolve => {
        setTimeout(() => {
            console.log('timer:', timer)
            resolve()
        }, timer)
    })
}

const task1 = creator(1500)
const task2 = creator(800)
const task3 = creator(2000)
const task4 = creator(300)

process.do([
    task1,
    task2,
    task3,
    task4
])


问题2：返回数组中前K大的数据

function getTopK(list, k) {
    
}


function getTopK(list, k) {
    return list.sort((a, b) => b - a)[k - 1]
}
console.log(getTopK([1,2,3,4,5,99,7], 3))

function quickSort(list) {
    let mid
    if (mid < k) {
        partition(0, mid)
    } else {
        partition(mid, left)
    }
    
    return mid
}


Promise.all
Promise.race

function getTopK(list, k) {
  return list.sort((a, b) => b - a)[k - 1]
}
console.log(getTopK([1,2,3,4,5,99,7], 3))

function quickSort(list) {
  let mid
  if (mid < k) {
      partition(0, mid)
  } else {
      partition(mid, left)
  }
  
  return mid
}

项目：Radar                                                        工作职责：业务运营、维护、开发和移动端适配
项目描述：本项目旨在提升告警、事件和故障处理的效率，通过整合多种功能模块，为用户提供高效的信息传递和决策支持。
核心功能
1.     告警与事件管理：自动化告警合并与事件生成，支持手动管理与合并，提升处理效率。
2.     故障处理：动态事件定级与调整，专门协控角色负责信息标记和通报。
3.     预案与应急管理：统一管理可执行预案，提升预案覆盖率，支持应急团队快速响应。
4.     信息整合与沟通：集中展示告警与事件关联信息，自动化沟通工具确保信息高效传递。
项目成果：预案覆盖率提升至80%，事件转化率提升至20%。响应率达45%，故障处理时长缩短至30分钟以内。项目交付稳定，月均任务量达到十个。
项目： AC                                        工作职责：开发、改版和移动端适配
项目描述：AC告警中心是一个统一的告警发送控制模块，旨在提升告警的精准性和有效性。通过集成各类监控平台的告警，并进行聚合和降噪处理，确保告警通知准确地传达给接收人。
核心功能
1.     告警接入与处理：提供告警接入入口，支持各类监控平台的告警集成；具备告警合并、处理和抑制功能，减少不必要的告警干扰。
2.     精准告警通知：通过聚合、降噪和抑制处理后，将告警通知发送给目标用户。
3.     统计与报表：提供历史告警的多维度统计报表，支持用户进行追溯和告警优化。
项目成果：完成了告警系统的大升级，重构了核心功能。项目成果获得业务方的高度认可，获得超过三次的积极反馈和点赞。
项目： COE                          工作职责：页面重构
项目描述：COE系统是公司统一的故障复盘平台，旨在帮助员工整理事故过程，深入分析事故原因，制定解决方案，并总结经验教训。该系统不仅促进了故障处理的系统化和透明化，还为管理者提供了评估团队工作状况的工具。
核心功能
1.     故障现象：记录故障发生时的现象和过程。
2.     客户影响：描述故障对客户的损失和业务影响程度。
3.     时间线：详细记录故障从发生到影响消除的全过程，包括时间点、处理动作、结果和原因简述。
4.     原因分析：使用“5Why分析法”深入挖掘故障根本原因。
5.     经验教训：记录故障中不当之处和吸取的教训。
6.     正确做法：总结避免故障的方法和处理过程中的良好实践。
项目成果：通过系统化的复盘流程，促进跨团队的知识共享和持续改进。为管理者提供清晰的工作状况评估，提高团队的响应能力和处理效率。
 
 
2019.07 - 2021.05                                                          万达信息股份有限公司                                             软件工程师
项目：销售日志                         工作职责：业务开发与维护
项目描述：该项目主要是开发一个便于销售管理人员随时随地都可以便捷的通过外网填报日报和周报等信息的系统平台：
项目模块：销售日项目主要分成日报、周报、日志审批、日报审核、周报审核、销售周报统计、销售日报统计、日报提交情况、每周客户拜访情况
项目职责：编写日报填写和日志审批、销售日报统计、日报提交情况页面，完成从日报申请到结束的页面开发和接口联调工作
项目：医养结合                                         工作职责：业务开发与维护项目描述：该项目主要是开发一个为老人服务，链接老人和服务中心纽带的平台，提供老人在家预约服务，服务中心上门服务的便利
项目模块：医养结合主要有老人信息、服务人员信息、机构信息、订单查询、订单派单五大模块
项目职责：负责服务人员信息和机构信息的模块开发和接口连接工作
项目：产品管理平台                                  工作职责：业务开发与维护
项目描述：产品管理平台主要是拓展人员使用范围、完善相关功能功能、与公司相关信息管理系统对接打通的一个平台；促进公司产品研发、规范产品管理，提升产品研发、交付、营销协作一体化，主要有用户权限管理、客户管理、产品管理、竞争对手管理、产品激励管理、综合查询、账户管理等模块项目成果: 客户管理和产品激励管理模块的前端页面开发以及后端接口的编写
自我评价

  具备技术PM项目经验，能充分协调好项目中各业务成员开发协同问题，制定项目技术方案，规范排期，规避风险等，使项目能够有条不紊持续进行，项目安全上线。
 具有技术推动业务持续性增长业务的意识，以个人项目经验和技术能力同PD沟通业务方案，为业务带来价值型增长。
u 具有主人翁精神，主动且持续推动业务迭代意识，做事有始有终，推进业务稳定增长。
 
 

联系方式
	•	手机：123-456-7890
	•	邮箱：example@example.com
	•	LinkedIn: linkedin.com/in/example
职业概况
	•	软件工程师，具备丰富的项目开发、故障处理和系统优化经验，专注于提升系统稳定性和用户体验。
核心技能
	•	编程语言：Java、JavaScript、TypeScript
	•	技术框架：Vue.js、React Native、Node.js
	•	工具与方法：Git、JIRA、5Why分析法、敏捷开发
工作经验
美团公司 软件工程师 20XX年X月 - 至今
	•	Radar项目：
	•	职责：负责业务运营、系统维护、功能开发及移动端适配。
	•	技术：使用Vue.js和Node.js开发前后端功能，优化系统性能。
	•	描述：整合多种功能模块，提升告警、事件和故障处理效率。
	•	贡献：优化告警合并算法，提升处理效率；设计并实施动态事件定级系统。
	•	成果：预案覆盖率提升至80%，事件转化率提升至20%，响应率达45%，故障处理时长缩短至30分钟以内。
	•	AC告警中心：
	•	职责：负责系统开发、改版及移动端适配。
	•	技术：采用React Native进行移动端开发，提升用户体验。
	•	描述：统一告警发送控制模块，提升告警精准性和有效性。
	•	贡献：重构告警处理流程，减少误报率；开发多维度统计报表功能。
	•	成果：完成告警系统大升级，获得业务方多次积极反馈。
	•	COE系统：
	•	职责：负责页面重构及系统优化。
	•	技术：使用现代前端技术优化页面性能，提高加载速度。
	•	描述：故障复盘平台，帮助员工整理事故过程，总结经验教训。
	•	贡献：实施5Why分析法，深入挖掘故障根本原因，优化复盘流程。
	•	成果：促进跨团队知识共享，提升团队响应能力和处理效率。
	•		•	部门公共组件建设项目：
	•	职责：负责跨部门公共组件的设计、开发和维护。
	•	技术：使用Vue.js、React和TypeScript开发可复用的UI组件库。
	•	描述：为公司内部多个部门构建公共组件库，提升开发效率和一致性。
	•	贡献：
	•	主导组件库的架构设计，确保组件的可扩展性和易用性。
	•	与设计团队紧密合作，确保组件符合UI/UX标准。
	•	编写详细的组件使用文档和示例，降低其他开发人员的学习成本。
	•	成果：
	•	成功上线超过50个高复用性组件，显著减少了各部门的开发时间。
	•	组件库被多个业务线采用，提升了产品界面的一致性和用户体验。
	•	项目获得公司技术部门的高度评价，并被作为内部标准推广。
	•	
万达信息股份有限公司 软件工程师 2019.07 - 2021.05
	•	销售日志项目：
	•	职责：负责业务开发与维护。
	•	技术：使用Java和Spring框架开发后台服务，确保数据安全和稳定。
	•	描述：开发销售管理平台，支持外网填报日报和周报。
	•	贡献：优化日报填写和日志审批流程，提升用户使用体验。
	•	成果：完成日报填写、日志审批及相关统计页面开发。
	•	医养结合项目：
	•	职责：负责业务开发与维护。
	•	技术：使用RESTful API设计实现服务人员和机构信息模块。
	•	描述：为老人服务的预约平台，提供居家预约和上门服务。
	•	贡献：开发并优化订单派单系统，提升服务响应速度。
	•	成果：成功上线服务人员信息和机构信息模块。
	•	产品管理平台：
	•	职责：负责业务开发与维护。
	•	技术：使用Vue.js和Spring Boot构建前后端系统。
	•	描述：拓展人员使用范围，完善功能，与公司信息系统对接。
	•	贡献：实现客户管理和产品激励管理模块，提升系统协作效率。
	•	成果：完成客户管理和产品激励管理模块的前端及后端开发。
自我评价
	•	具备丰富的技术项目管理经验，能够协调项目成员，制定技术方案，规范排期，规避风险，确保项目顺利上线。
	•	具有推动业务增长的意识，与产品经理紧密合作，制定业务方案，实现价值型增长。
	•	拥有主人翁精神，主动推动业务迭代，确保项目有始有终，促进业务稳定增长。


// <WebView
      //   containerStyle={{height: this.state.contentHeight}}
      //   ref={view => {
      //     this.commentWeb = view
      //   }}
      //   originWhitelist={['*']}
      //   source={{html, baseUrl: ''}}
      //   showsVerticalScrollIndicator={false}
      //   injectedJavaScript={BaseScript}
      //   automaticallyAdjustContentInsets
      //   decelerationRate="normal"
      //   scalesPageToFit={false}
      //   javaScriptEnabled // 仅限Android平台。iOS平台JavaScript是默认开启的
      //   scrollEnabled={false}
      //   onMessage={this.onMessage}
      //   mixedContentMode="always"
      //   onLoadEnd={() => {
      //     this.commentWeb.injectJavaScript(BaseScript)
      //   }}
      // />

      // <View>
      //   <Text>100</Text>
      //   <WebView
      //     containerStyle={{height: 300, width: 100}}
      //     ref={view => {
      //       this.commentWeb = view
      //     }}
      //     source={{
      //       // {uri: 'https://radar.mws.sankuai.com/operation-sidebar?eventId=2851302'}
      //       html: '<div>ceshi100</div>'
      //     }}
      //     showsVerticalScrollIndicator={true}
      //     automaticallyAdjustContentInsets={true}
      //     scalesPageToFit={true}
      //     javaScriptEnabled={true}
      //     domStorageEnabled={true}
      //     startInLoadingState={true}
      //     onLoadEnd={() => {
      //       console.log('WebView加载完成')
      //     }}
      //   />
      // </View>



# sass

# ----------------------------------------------------------------------------------------------------------------

# vue

## 组件和插件的区别
    组件：将图形和非图形抽象为同一个的概念，降低耦合度，方便调试，可维护性高
    插件：插件就是对Vue功能的一个补充，添加全局方法和属性，或者添加vue实例方法（vue.prototype中实现），提供多个API的库（像vue-router,vue-touch）
    注册：vue.component(组件)，vue.use(插件)，插件注册需要在new vue()之前，注册相同的插件会注册一次
    编写：一个.vue结尾的文件就是一个组件，插件是需要plugin.install(Vue,option)暴露一个install方法
    使用场景：组件是构成app的业务模块，插件是增强技术栈的功能，对vue的增强和补充

## 组件间的通信
    props:父传子
    $emit:子传夫
    ref:获取子组件的实例，通过实例条用方法
    EventBus:使用一个新的vue实例作为总线，$on(),$emit()监听和触发事件
    $parent,$root:共同的父辈。兄弟组件间通信
    attr,listeners:传递除props外的其他属性和方法
    provide,inject
    Vuex

## route和router的区别
    route:单个路由的规则
    router:路由的集合

# ----------------------------------------------------------------------------------------------------------------

# 项目
    radar:
        预案覆盖率: 分母（生成的所有事件），分子（超过三分钟为有效事件，所以真实的时间比radar项目中全部事件菜单中的事件多，这个会通知em(事件唯一的ID)）;推荐有多种渠道,比如： 通过诊断结果推荐，通过历史相似推荐， 通过api异常推荐，通过用户配置的故障场景和预案关系推荐等
        处理时长: 所有事件的平均时长
        事件转化率：
        
    告警:
        响应率：告警已响应数据/告警总量；（三分钟内恢复但是未响应的排除），拉群处理和静默都算响应
        转事件处理率：事件处理/ac转为事件，（用户手动拉群或者静默都会转事件，还有就是radar配置了对应的规则主动去ac拉的数据）

# ----------------------------------------------------------------------------------------------------------------

# javaScript
## 前端数据类型
    基础类型（存储在栈中）：number、sting、null、undefined、boolean、bigint（大范围的数据）、System()（唯一不会重复出现，适合做对象key）
    引用类性（存储在堆中）：数组、对象

## null和undefined区别
    null：定义为赋值null
    undefined：定义未赋值

## 判断数据类型的方法
    typeof: 判断null和object的时候打印为object,函数为function，其他基础类型是啥打印啥（补充：NaN是number类型的）
    Object.prototype.toString.call(),所有类型都能判断，例：Object.prototype.toString.call(null) 打印：'[object Null]',其他类型都是类似格式
    constructor: 获取原型 数组为"f Array() { [native code] }" console.log([] instanceof Array) true; 
        对象"f Object() { [native code] }",    console.log(obj instanceof Object) true console.log({} instanceof Object) false //可能是函数{}

## 事件循环
    js任务分为同步任务和异步任务，异步任务分为宏任务和微任务，js是单线程的，总是先执行同步任务，遇到宏任务加入宏任务队列，遇到微任务加入微任务队列，执行万同步任务，在执行微任务队列，执行万微任务队列在执行宏任务，如此循环。
    微任务：promise(.then的才是微任务)，async/await(await所在行内容还是立即执行，await的后面才是微任务)
    宏任务：script，link，事件，setTimeout（），ajax

## 深拷贝
    lodash的cloneDeep,
    JSON.parse(JSON.stringify())(序列和反序列化)，有局限性，例：undefined,function,symbol,无法处理

## 浅拷贝
    {...obj}
    Object.assign() //  浅拷贝,对于嵌套的对象是引用,例：{uname: 'pink',{baby: 'pink'} },使用assign()拷贝的话baby所在的属性被修改了所有的对象都会受影响

## 构造函数是一种函数，用来初始化对象
	构造函数是用大写，使用构造需要用new

## new 对象的过程：(这里的this就是实例对象),new会创建新的对象
    创建新空对象
    构造函数this指向新对象
    执行构造函数，修改this，添加新的属性
    返回新对象

## 实例成员和静态成员
    构造函数中的属性和方法为静态成员，静态方法中的this指向构造函数，静态成员只能构造函数使用
    实例对象中的属性和方法为实例成员

## 类的两种写法
    ### 1. 类声明  
        class Test {
            constructor(name) {
                this.name = name
            }
        }
        const a = new Test('test')
        console.log(a.constructor) // class Test { constructor(name){ this.name = name } }
        console.log(a.__proto__) // {}
        console.log(a.prototype) // undefined
        console.log(Test.constructor) // f Function() { [native code] }
        console.log(Test.__proto__) // f () { [native code] })
        console.log(Test.prototype) // {}

    ### 2. 构造函数
        function Test(name) {
            this.name = name
        }
        const a = new Test('test')
        const c = new Test('test2')
        console.log(a.=== c) // false
        console.log(a) // Test { name: 'test' }
        console.log(a.constructor) // f Test() { this.name = name }
        console.log(a.__proto__) // {}
        console.log(a.prototype) // undefined
        console.log(Test.constructor) // f Function() { [native code] }
        console.log(Test.__proto__) // f () { [native code] }
        console.log(Test.prototype) // {}

    ### 3. 类在浏览器控制台的真实打印
        function jk(name){
            this.name = name;
        }
        jk.prototype.say = function() {
            console.log('hi')
        }
        const p = new jk();
        console.log(p) // f jk(name) { this.name = name }
        console.log(p.constructor) // f jk (name) { this.name = name; }  
        console.log(p.__proto__.constructor) // f jk (name) { this.name = name; }
        console.log(p.__proto__) // {say: f}
        console.log(p.constructor.prototype) //  {say: f}
        console.log(p.prototype) // undefined
        console.log(p.constructor.__proto__) // f () { [native code] }
    
        console.log(jk) // f jk(name) { this.name = name }
        console.log(jk.prototype) // {say: f}
        console.log(jk.constructor) // f Function() { [native code] }    
        console.log(jk.__proto__.constructor) // f Function() { [native code] }
        console.log(jk.__proto__) // f () { [native code] }
        console.log(jk.constructor.__proto__) // f () { [native code] }
        console.log(jk.constructor.prototype) // f () { [native code] }

## prototype,构造函数都有的原型属性，指向对象故称原型对象
    ### 1.为啥会有这个呢，它解决什么问题？
        function Test(name) {
            this.name = name
            this.say = function() {
                console.log(this.name)
            }   
        }
        const a = new Test('test')
        const b = new Test('test2')
        console.log(a.say === b.say) // false,重点来了，每实例一次，都会在堆中开辟一个空间，但是如果使用相同复杂对象（比如说say方法）的时候会造成空间浪费，因为像say方法在每一个实例中都是不同的，但是say方法功能是一样的，所以这个时候就可以使用prototype，这样只会存在一份say方法。
        Test.prototype.say = function() {
            console.log(this.name)
        }
        const a = new Test('test')
        const b = new Test('test2')
        console.log(a.say === b.say) // true
        结论：公共的属性放在方法中，公共的方法放在prototype中

## 构造函数的this就是实例对象；原型对象的this指向使用者；其实总的来说就是指向实例对象
    let _this
    function Test(name) {
        _this = this
        this.name = name
    }
    Test.prototype.say = function() {
        console.log(100,this)
    }
    const a = new Test('test')
    a.say() // 100 { name: 'test' }
    console.log(_this) // { name: 'test' }

    例：
        Array.prototype.max = function() {
            return Math.max(this) // 这里的this是数组jk/[1,2,3,4,5],谁使用就指向谁。
        }
        const jk = [1,2,3,4,5]
        console.log(jk.max()) // 5
        console.log([1,2,3,4,5].max()) // 5

## constructor(原型对象的构造函数/构造器),原型对象（prototype）和实例对象的对象原型（__proto__）都有的属性，指向构造函数
    function Test(name){
        this.name = name
    }
    console.log(Test.prototype.constructor) // f Test() { this.name = name }
    采用追加的方式写是不易出错的，但是局限于一个一个写
    Test.prototype.say = () => {
        console.log('say')
    }
    这种多个方法的时候容易出错，容易丢失constructor,需要注意加入constructor
    Test.prototype = {
        say: () => {
            console.log('say')
        }
        ceshi: () => {
            console.log('ceshi')
        }
    }
    console.log(Test.prototype.constructor) // undefined

    Test.prototype = {
        constructor: Test, // 如果不加这个，就不会清楚prototype属于谁。
        say: () => {
            console.log('say')
        }
        ceshi: () => {
            console.log('ceshi')
        }
    }
    const jk = new Test('test')
    console.log(jk.__proto__.constructor === jk.constructor) // true
    console.log(jk.__proto__) // {}
    console.log(Test.prototype.constructor) // f Test() { this.name = name }

## __proto__（对象原型），实例对象都有的属性，所有的对象也有这个属性，指向原型对象（prototype）;也有constructor属性,指向创建实例对象的构造函数,__proto__在浏览器控制台是看不到的，其实就是[[Prototype]]
    function Test(name) {
        this.name = name
    }
    const jk = new Test('test')
    console.log(jk.__proto__) // {}
    console.log(jk.__proto__ === Test.prototype) // true
    console.log(jk.__proto__.constructor) // f Test() { this.name = name }

## 原型链继承
    ### 正确使用：
        function Test(name) {
            this.name = name
        }
        Test.prototype.say = function() {
            console.log('say')
        }
        function JK() {

        }
        JK.prototype = new Test('test')
        const jk = new JK()
        console.log(jk.name) // test
        console.log(jk.__proto__ === JK.prototype) // true
        console.log(jk.__proto__.__proto__ === Test.prototype) // true

    ### 错误示范：
        const Person = {
            eyes: 2,
            head: 1
        }

        function Man() {

        }

        function Woman() {

        }
        Man.prototype = Person
        Man.prototype.constructor = Man
        Man.prototype.say = function() { //  这样添加的方法在实例中都是共享的,因为man.prototype和woman.prototype都指向person,person中添加的方法在man和  woman中都是共享的,所以需要改变person为函数,通过构造函数使用new实例对象,这样才可以单独在其中添加方法,不在公用方法。
            console.log('Man say')
        }
        console.log(Man) // f Man() { } 中的__proto__会有eyes、head和say

        Woman.prototype = Person
        Woman.prototype.constructor = Woman
        console.log(Woman) // f Woman() { } 中的__proto__会有eyes、head和say

    ### 正确示范（如果想单独为man添加方法，woman则不需要）：
        function Person = {
            eyes: 2,
            head: 1
        }
        function Man() {

        }

        function Woman() {

        }
        Man.prototype = new Person()
        Man.prototype.constructor = Man
        Man.prototype.say = function() { // new的实例是返回新的数组，所以在这加个方法，man和woman中都是不共享的。
            console.log('Man say')
        }
        console.log(Man) // f Man() { } 中的__proto__会有eyes、head和say

        Woman.prototype = new Person()
        Woman.prototype.constructor = Woman
        console.log(Woman) // f Woman() { } 中的__proto__会有eyes、head

##  原型链
    ### 原型其实就是一种查询规则，通过原型链（__proto__）可以找到某个属性
    当访问某个属性的时候，
    1. 先查自己
    2. 如果没有就在原型（__proto__）中找
    3. 如果还没有，就在原型对象（prototype）中找
    4. 如果还没有原型对象也是一个对象，也有自己的原型（__proto__）,也就是Object的原型对象
    5. 以此类推到null为止
    __proto__对象原型的意思就是为查找寻找一个方向，或者说一条路线

    function Person() {

    }  
    const ldh = new Person()                                                  时刻记住ldh.__proto__ === Person.prototype
    ldh.ceshi() // ldh对象想要访问ceshi方法，但是ldh中没有，但是通过对象本身原型（ldh.__proto__），所以就会去Person(也就是Person.prototype)中找，Person中也没有，所以就会去Person.prototype的原型(Person.prototype.__proto__)中找，找不到继续往上找，也就是Object(Object.prototype),找不到的话原型对象的原型(Object.prototype.__proto__),以此类推到null 

    ### instanceof，判断某个对象是否属于某个构造函数, 凡是出现在原型链中的都为true 
    console.log(ldh instanceof Person) // true
    console.log(ldh instanceof Object) // true
    console.log(ldh instanceof Array) // false
    console.log(Array instanceof Object) // true
    console.log(Person.prototype instanceof Object) // true 

    console.log(Person.prototype.__proto__ === Object.prototype) // true
    console.log(Object.prototype__proto__) // null

    <div class="fun"></div>
    <mtd-button type="primary" class="del">删除</mtd-button>
    <mtd-button type="primary" class="login">登录</mtd-button>
    function Jk(title,message){
        this.ceshi = document.createElement('div')
        this.ceshi.className = 'jk'
        this.ceshi.style.color = 'pink'
        this.ceshi.innerHTML = `<div>
        <div>${title}<i>X</i></div>
        <div>${message}</div>
        </div>`
    }
    Jk.prototype.open = function() {
        if(document.querySelector('.jk')){
            this.remove
        }else{
        document.querySelector('.fun').append(this.ceshi)
        document.querySelector('i').addEventListener('click', ()=> { // 这需要使用箭头函数，否则this指向的是i
            this.close()
        })
        }
    }

    Jk.prototype.close = function() { // 这需要this指向实例对象, 所以不能使用箭头函数，在原型对象中最好都是使用追加的形式；否则还需要使用constructor指回构造函数，添加多个方法的时候可以将对象合集赋值给prototype，在使用constructor指回构造函数。例：Jk.prototype = {constructor: Jk,close:function()=>{},...}
        this.ceshi.remove()
    
    }
    
    document.querySelector('.del').addEventListener('click', ()=> {
       const p = new Jk('删除','删除成功')
       p.open()
    })

## 数组的方法
    splice(start,count,item1,item2,item3) // 删除指定位置的内容，count表示删除的数量，item1,item2,item3表示要添加的内容，会改变原数组，返回删除的内容
    slice(start,end) // 截取数组，end不包含，不改变数组，返回截取的内容


## 字符串方法
    startWith: 判断字符串是否以指定字符开头
    substring: 截取字符串，arr.substring(start,end)返回之间的内容，
    toUpperCase: 转大写
    toLowerCase: 转小写
    indexOf: 查找字符串，返回指定内容首次出现的内容,未找到返回-1
    slice: 截取字符串arr.slice(start,end),不改变原数组
    split: 分割字符串，返回数组


## 数字方法
    toFixed(2): 保留两位小数

## import和require的区别
    1. require是同步加载，import是异步加载
    2. require是动态加载，import是静态加载，必须要放在script最顶部
    3. import支持tree-shaking,不使用会移除；require不支持tree-shaking
    4. import原生支持浏览器；require主要使用于node,在浏览器中使用需要babel转义

## tree-shaking
    移除未使用的代码，减少代码体积。针对es6的模块化的打包工具

## 高阶函数
    1. 函数可以作为参数传递给另一个函数
    2. 函数可以作为另一个函数的返回值

## 闭包
    1. 函数嵌套函数
    2. 内部函数可以引用外部函数的参数和变量
    3. 内部函数作为返回值

## 定位
    position: relative; // 相对定位
    position: absolute; //  绝对定位
    position: fixed; //  固定定位
    position: sticky; // 粘性定位
    position: static; //  默认定位
    position: inherit; // 继承父元素的定位方式

定位
高阶函数
理解模块化
居中
怎么解决线上跨域
数组方法

## 双向绑定组件的时候不可以父子组件同时使用v-model
    ### 第一种方式
    1.在父组件中可以使用 
    <Child v-if="visible" :visible="visible"  @close="close" />
    2.子组件中
    created(){
        this.childVisible = this.visible
    }
    <mtd-drawer v-model="childVisible"><mtd-drawer>

    ### 第二种方式
    1.父组件
    <Child v-model="visible" @close="close" />
    2.子组件
    props: ['visible'],
    created(){
        this.childVisible = this.visible
    }
    <mtd-drawer :visible="childVisible"><mtd-drawer>

## 重绘和重排
    重绘：元素外观变化，如颜色、背景色、字体大小等
    重排：元素位置变化，如宽高、布局等，触发重排会导致重绘；因为重排会改变元素的位置，所以重绘也会跟着改变，table布局需要更多的计算会花费其他布局三倍的时间，所以尽量少使用table布局。

## es6的新特性
    1. let和const
    2. 箭头函数
    3. 模板字符串
    4. 解构赋值
    5. 展开运算符
    6. 类
    7. 模块
    8. promise
    9. async和await
    10. 生成器函数
    11. 代理
    12. 映射
    13. 集合
    14. 迭代器

## route和router的区别
    1. route是路由信息对象，包含了当前路由的信息
    2. router是路由实例对象，包含了路由的跳转方法
    3. router实例对象可以获取route实例对象
    4. route实例对象不能获取router实例对象

## 路由的几种传参方式
    1. params参数
    1. 配置路由时，使用:声明接收params参数
    2. 传递参数时，在path中声明变量名
    3. 接收参数时，使用this.$route.params获取
    4. 特点：参数通过路径传递，参数会显示在地址栏中
    5. 刷新页面不会重置参数
    6. 路由跳转时，参数会丢失
    7. 路由跳转时，参数不会丢失
    8. 路由跳转时，参数不会丢失

    2. query参数
    1. 配置路由时，使用?声明接收query参数
    2. 传递参数时，在path中声明变量名
    3. 接收参数时，使用this.$route.query获取
    4. 特点：参数通过路径传递，参数不会显示在地址栏中
    5. 刷新页面不会重置参数
    6. 路由跳转时，参数会丢失
    7. 路由跳转时，参数不会丢失

    3. state参数
    1. 配置路由时，使用:声明接收state参数
    2. 传递参数时，在path中声明变量名
    3. 接收参数时，使用this.$route.state获取
    4. 特点：参数通过路径传递，参数不会显示在地址栏中
    5. 刷新页面不会重置参数
    6. 路由跳转时，参数不会丢失

## for in、forEach、for of的区别
    1. for in 遍历的是对象的键名
    2. forEach 遍历的是数组的值，如果需要使用索引一般是用这个，不能中断循环
    3. for of 遍历的是数组的值，执行速度较快，数组首选，可以使用break跳出循环,continue跳过当前循环,return跳出整个循环


## display: none; visibility: hidden; opacity: 0; overflow: hidden;的区别
    1. display: none; 隐藏元素，不保留位置
    2. visibility: hidden; 隐藏元素，保留位置
    3. opacity: 0; 隐藏元素，保留位置
    4. overflow: hidden; 隐藏元素，保留位置

## 组件间的通信
    1. props / $emit
    - 父组件通过 props 向子组件传递数据
    - 子组件通过 $emit 触发事件向父组件发送消息

    2. $refs
    - 父组件通过 $refs 获取子组件实例,可以直接调用子组件的方法

    3. EventBus
    - 使用一个空的 Vue 实例作为中央事件总线
    - 组件通过 $emit 触发事件,$on 监听事件

    4. $parent / $root
    - 通过 $parent 访问父组件
    - 通过 $root 访问根组件

    5. provide / inject
    - 父组件通过 provide 提供数据
    - 子孙组件通过 inject 注入数据

    6. $attrs / $listeners
    - $attrs 包含父作用域中不作为 prop 被识别的特性绑定
    - $listeners 包含父作用域中的 v-on 事件监听器

## Vuex
    1. state 存放数据
    2. getters 计算属性
    3. mutations 修改数据
    4. actions 异步修改数据
    5. modules 模块
    6. plugins 插件
    7. mapState 辅助函数
    8. mapGetters 辅助函数
    9. mapMutations 辅助函数
    10. mapActions 辅助函数
    11. mapModules 辅助函数

## 插槽
    1. 默认插槽
    2. 具名插槽
    3. 作用域插槽
    4. 动态插槽
    5. 解构插槽
    6. 渲染函数插槽
    7. 渲染内容插槽
    8. 编译时插槽
    9. 运行时插槽

## watch和computed的区别
    1. watch 监听数据变化
    2. computed 计算属性
    3. computed 计算属性是缓存，watch不是
    4. computed 计算属性是方法，watch是对象
    5. computed 计算属性是响应式，watch不是
    6. computed 计算属性是同步的，watch是异步的
    7. computed 计算属性是懒加载的，watch是同步的
    8. computed 计算属性是只读的，watch是读写
    9. computed 计算属性是深度监听，watch是深度监听
    10. computed 计算属性是函数，watch是对象

## 有哪些性能方面的手段
    1. 减少请求数量
    2. 减少请求大小
    3. 减少请求次数
    4. 缓存
    5. 压缩
    6. 合并
    7. 预加载
    8. 懒加载
    9. 减少DOM操作
    10. 减少样式操作
    11. 减少回流和重绘
    12. 减少动画操作
    13. 减少事件监听

## 代码相关提升性能的手段
    1. 减少if else
    2. 减少循环
    3. 减少函数调用
    4. 减少DOM操作
    5. 减少样式操作
    6. 减少回流和重绘
    7. 减少动画操作
    8. 减少事件监听

## 浏览器缓存
    1. 强缓存
    2. 协商缓存
    3. 缓存位置
    4. 缓存控制
    5. 缓存策略

## 内存泄漏
    1. 全局变量
    2. 闭包
    3. 定时器
    4. 事件监听
    5. 子组件未销毁
    6. 循环引用
    7. 缓存

## 根据组织id在组织树中找到对应的组织路径
handleFindOrg(orgs, org) {
    const findPath = (orgs, org, path = []) => {
        for (const j of orgs) {
            const current = [...path, j.value];
            if (j.value === org) {
                return j;
            }
            if (j.children?.length) {
                const path = findPath(j.children, org, current);
                return path;
            }
        }
        return [];
    };
    return findPath(orgs, org);
}

## 空值合并操作符
    res?.result ?? -1; // 如果res?.result存在且不为null或undefined,则返回res?.result,否则返回-1

## while前置运算符和后置运算符的区别
    let data = [1,2,3]
    let j = this.data.length
    1. 前置运算符先执行--，后执行语句
        while(--j){
            console.log(j,this.data[j]) // 2 1 
            // j:2 1
            // this.data[j]: 3 2                
        }
    2. 后置运算符先执行语句，后执行--
    while(j--){ // 先判断是否能进入循环再计算，比如开始j等于3,可以进入循环，j--后等于2，this.data[j]等于3。
        console.log(j,this.data[j]) 
        // j:2 1 0
        // this.data[j]: 3 2 1
    }

## call、apply、bind的区别
	第一参数都是this的指向对象，其他参数call是直接放进去，apply是以数组的形势，bind和call一样，但是返回的是一个函数，需要手动执行

## Let,const,var的区别
	var全局的作用域，let和const是块级，var可以重新声明和更新，let可以更新，const不可重新声明不可更新，var和let可以声明不初始化，const必须声明的时候初始化

## http/1.0
	需要keep-alive参数长链接，每次请求都要发起tcp请求，tcp的链接和释放比较耗时，下一次请求需要等上一次请求到达响应后才能发起
## http/1.1
	tcp长链接，只要不是长时间不进行数据交互或者双方断开连接可以一直请求，发起的时候不需要等上一次到达响应(管道传输)，但是返回的时候需要按照发起的顺序返回，使用header-body的方法，header使用key-value的方式，比较灵活，易扩展
## https：
	在tcp和http之间加了个ssl/tls层
## http/2.0：
	在https的基础上做的，头部压缩（多个请求头部相同或者相似，服务端和客户端会维护一张表，后续请求通过序号就好了，节省内存），二进制格式传输（使用二进制传输，之前的http/1是使用文本传输，传输过去服务端还需要转二进制，多路复用（使用http/2.0现在就能提高效率了）,不会有队头阻塞时，请求和返回都没有，有也是在tcp中）；服务端推送（服务端可以主动向客户端推送消息）
## 错题

http的版本
	http/1.0: 每次请求都要建立tcp连接，无法复用，tcp的链接和释放比较耗时；1.0的每次次请求都要等上一次请求响应到达才能发起（这就是队头阻塞）
	http/1.1:header+body的方法，已扩展，较灵活，跨平台，广泛应用；
	https: 在

同源：协议、域名、端口都相同叫同源，否则需要跨域

跨域方法： 
	proxy转发（使用页面同域的服务器转发）
	服务器添加响应头：cros(access-control-allow-orgin)
	json:使用script的src

cookie:大小不超过4k,同源窗口共用，浏览器和服务端进行传递
localStorage:可以达到5m或更大，同源窗口共用
sessionStorage: 可以达到5m左右，当前窗口可以用，窗口关闭失效


fetch和ajax的区别
	fetch:基于promise的API，更简洁方便，方便链式调用，回调，解决错误 	ajax:使用xmlhttprequest发送和接收数据，支持服务器加载数据不刷新页面


get和post的区别以及不同版本参数的大小限制
	get一般放在URL，数据大小有限制2KB，请求可以被缓存
	post放在body中，数据大小无限制，请求不可以被缓存

数组的遍历方法以及区别


深浅拷贝的区别以及相应的方法
怎么使用cookie
请求状态码的区别
cookie的各种类型 项目开发过程中的比较有趣体会和经历
localStroge
有什么想问的

微任务、宏任务

将一个嵌套数组的深度遍历和广度遍历写出来

递归


## 网络请求
http/1.0
	需要keep-alive参数长链接，每次请求都要发起tcp请求，tcp的链接和释放比较耗时，下一次请求需要等上一次请求到达响应后才能发起
http/1.1
	tcp长链接，只要不是长时间不进行数据交互或者双方断开连接可以一直请求，发起的时候不需要等上一次到达响应(管道传输)，但是返回的时候需要按照发起的顺序返回，使用header-body的方法，header使用key-value的方式，比较灵活，易扩展
https：
	在tcp和http之间加了个ssl/tls层
http/2.0：
	在https的基础上做的，头部压缩（多个请求头部相同或者相似，服务端和客户端会维护一张表，后续请求通过序号就好了，节省内存），二进制格式传输（使用二进制传输，之前的http/1是使用文本传输，传输过去服务端还需要转二进制，多路复用（使用http/2.0现在就能提高效率了）,不会有队头阻塞时，请求和返回都没有，有也是在tcp中）；服务端推送（服务端可以主动向客户端推送消息）

 # 创建react项目
    npx create-react-app react-basic

# jsx 
    html和javascript的结合，js的语法扩展，需要babel变异才能在浏览器中运行

# useState
    useState会向组件中添加状态变量，与普通js变量不同是的，状态变量一旦有所变化视图会跟着变化

# 数据驱动视图
    useState会向组件中添加状态变量，与普通变量不同是的，状态变量一旦有所变化视图会跟着变化，这就是所谓的数据驱动视图

# classnames库: react 常用库
    className={classnames('',{active: type === item.type})}

# 组件通信
    function App(){
        const getMsg = ()=>{
            console.log('getMsg')
        }
        return (<div>
            <Son  onGetSonMsg={geMsg} onClick=(()=>{})> // 组件内部的东西会在子组件中的props的children属性中
                <span>100</span>
            </Son>
        </div>)
    }

    function Son(props){
        console.log(props.children) // 100
        return (<div onClick={()=>props.geMsg(100)}>
            {props.children}
        </div>)
    }  

    function A(props){
    const name = 'this is A name'
    return (<div>this is A name
        <button onClick={()=>{props.onGetAName(name)}}>click</button>
    </div>)
}

## 状态提升
    function B(props){
        return (<div>this is B name{props.name}</div>)
    }

    function App() {
        const [name, setName] = useState('');
        const getAName = (name)=>{
            console.log(name)
            setName(name)
        }
        
        return (
            <div className="App">
                <A onGetAName={getAName}/>
                <B name={name}/>
            </div>
        );
    } 


    import { createContext } from "react";
## Context跨层使用组件传递数据
const context = createContext()
const styles = {
  color: 'red',
  fontSize: '60px'
}

function A(props){
    const name = 'this is A name'
    return (<div>this is A name
        <B />
    </div>)
}

function B(props){
    const value = useContext(context) // 接收context.Provider中的value
    return (<div>this is B name{value}</div>)
}

function App() {
    const [name, setName] = useState('this is App');
    const getAName = (name)=>{
        console.log(name)
        setName(name)
    }
    
    return (
        <div className="App">
            <context.Provider value={name}> // context.Provider 组件提供数据
                this is App
                <A onGetAName={getAName}/>
            </context.Provider>
        </div>
    );
}

# useEffect,主要用于渲染完毕之后执行一些副作用操作，非事件处理函数，渲染完毕立马执行,有渲染引起的操作可以用这个
    useEffect(()=>{
        console.log('useEffect')
    },[])  // 第二个参数为空数组时，useEffect只执行一次

    依赖项为空数组时，useEffect只初始渲染的时候执行一次
    依赖项没有的时候，useEffect每次渲染都会执行，就是组件更新（比如说任何状态数据变化的时候，组件就会更新，这个时候useEffect会再次执行）的时候执行
    依赖项有的时候，useEffect初始渲染 + 当依赖项变化的时候执行

## 所谓副作用操作就是useEffect中由渲染引起的对接组件外部的操作，比如发送ajax请求，添加定时器，绑定事件等，在组件卸载的时候需要将定时器清除，事件解绑等
    useEffect(()=>{
       // 实现副作用操作逻辑
        return ()=>{ // 清除副作用的函数常见的时机就是在组件卸载是自动执行
            // 清除副作用操作
        }         
    },[])

hook需要在组件内使用，不可以在if for等条件中使用


# 项目：Radar                                                        
# 工作职责：业务运营、维护、开发和移动端适配
# 项目描述：本项目旨在提升告警、事件和故障处理的效率，通过整合多种功能模块，为用户提供高效的信息传递和决策支持。
# 核心功能
1.     告警与事件管理：自动化告警合并与事件生成，支持手动管理与合并，提升处理效率。
2.     故障处理：动态事件定级与调整，专门协控角色负责信息标记和通报。
3.     预案与应急管理：统一管理可执行预案，提升预案覆盖率，支持应急团队快速响应。
4.     信息整合与沟通：集中展示告警与事件关联信息，自动化沟通工具确保信息高效传递。
# 项目成果：预案覆盖率提升至80%，事件转化率提升至20%。响应率达45%，故障处理时长缩短至30分钟以内。项目交付稳定，月均任务量达到十个。
# 项目： AC                                        
# 工作职责：开发、改版和移动端适配
# 项目描述：AC告警中心是一个统一的告警发送控制模块，旨在提升告警的精准性和有效性。通过集成各类监控平台的告警，并进行聚合和降噪处理，确保告警通知准确地传达给接收人。
# 核心功能
1.     告警接入与处理：提供告警接入入口，支持各类监控平台的告警集成；具备告警合并、处理和抑制功能，减少不必要的告警干扰。
2.     精准告警通知：通过聚合、降噪和抑制处理后，将告警通知发送给目标用户。
3.     统计与报表：提供历史告警的多维度统计报表，支持用户进行追溯和告警优化。
# 项目成果：完成了告警系统的大升级，重构了核心功能。项目成果获得业务方的高度认可，获得超过三次的积极反馈和点赞。
# 项目： COE                          
# 工作职责：页面重构
# 项目描述：COE系统是公司统一的故障复盘平台，旨在帮助员工整理事故过程，深入分析事故原因，制定解决方案，并总结经验教训。该系统不仅促进了故障处理的系统化和透明化，还为管理者提供了评估团队工作状况的工具。
# 核心功能
1.     故障现象：记录故障发生时的现象和过程。
2.     客户影响：描述故障对客户的损失和业务影响程度。
3.     时间线：详细记录故障从发生到影响消除的全过程，包括时间点、处理动作、结果和原因简述。
4.     原因分析：使用“5Why分析法”深入挖掘故障根本原因。
5.     经验教训：记录故障中不当之处和吸取的教训。
6.     正确做法：总结避免故障的方法和处理过程中的良好实践。
# 项目成果：通过系统化的复盘流程，促进跨团队的知识共享和持续改进。为管理者提供清晰的工作状况评估，提高团队的响应能力和处理效率。
 
 
# 2019.07 - 2021.05                                            万达信息股份有限公司                                             软件工程师
# 项目：销售日志                         
# 工作职责：业务开发与维护
# 项目描述：该项目主要是开发一个便于销售管理人员随时随地都可以便捷的通过外网填报日报和周报等信息的系统平台：
# 项目模块：销售日项目主要分成日报、周报、日志审批、日报审核、周报审核、销售周报统计、销售日报统计、日报提交情况、每周客户拜访情况
# 项目职责：编写日报填写和日志审批、销售日报统计、日报提交情况页面，完成从日报申请到结束的页面开发和接口联调工作
# 项目：医养结合                                         
# 工作职责：业务开发与维护项目描述：该项目主要是开发一个为老人服务，链接老人和服务中心纽带的平台，提供老人在家预约服务，服务中心上门服务的便利
# 项目模块：医养结合主要有老人信息、服务人员信息、机构信息、订单查询、订单派单五大模块
# 项目职责：负责服务人员信息和机构信息的模块开发和接口连接工作
# 项目：产品管理平台                                  
# 工作职责：业务开发与维护
# 项目描述：产品管理平台主要是拓展人员使用范围、完善相关功能功能、与公司相关信息管理系统对接打通的一个平台；促进公司产品研发、规范产品管理，提升产品研发、交付、营销协作一体化，主要有用户权限管理、客户管理、产品管理、竞争对手管理、产品激励管理、综合查询、账户管理等模块项目成果: 客户管理和产品激励管理模块的前端页面开发以及后端接口的编写
# 自我评价
具备技术PM项目经验，能充分协调好项目中各业务成员开发协同问题，制定项目技术方案，规范排期，规避风险等，使项目能够有条不紊持续进行，项目安全上线。具有技术推动业务持续性增长业务的意识，以个人项目经验和技术能力同PD沟通业务方案，为业务带来价值型增长。具有主人翁精神，主动且持续推动业务迭代意识，做事有始有终，推进业务稳定增长。
 
 

# 联系方式
	•	手机：123-456-7890
	•	邮箱：example@example.com
	•	LinkedIn: linkedin.com/in/example
# 职业概况
	•	软件工程师，具备丰富的项目开发、故障处理和系统优化经验，专注于提升系统稳定性和用户体验。
# 核心技能
	•	编程语言：Java、JavaScript、TypeScript
	•	技术框架：Vue.js、React Native、Node.js
	•	工具与方法：Git、JIRA、5Why分析法、敏捷开发
工作经验
# 美团公司 软件工程师 20XX年X月 - 至今
# 	•	Radar项目：
# 	•	职责：负责业务运营、系统维护、功能开发及移动端适配。
# 	•	技术：使用Vue.js和Node.js开发前后端功能，优化系统性能。
# 	•	描述：整合多种功能模块，提升告警、事件和故障处理效率。
# 	•	贡献：优化告警合并算法，提升处理效率；设计并实施动态事件定级系统。
# 	•	成果：预案覆盖率提升至80%，事件转化率提升至20%，响应率达45%，故障处理时长缩短至30分钟以内。
# 	•	AC告警中心：
# 	•	职责：负责系统开发、改版及移动端适配。
# 	•	技术：采用React Native进行移动端开发，提升用户体验。
# 	•	描述：统一告警发送控制模块，提升告警精准性和有效性。
# 	•	贡献：重构告警处理流程，减少误报率；开发多维度统计报表功能。
# 	•	成果：完成告警系统大升级，获得业务方多次积极反馈。
# 	•	COE系统：
# 	•	职责：负责页面重构及系统优化。
# 	•	技术：使用现代前端技术优化页面性能，提高加载速度。
# 	•	描述：故障复盘平台，帮助员工整理事故过程，总结经验教训。
# 	•	贡献：实施5Why分析法，深入挖掘故障根本原因，优化复盘流程。
# 	•	成果：促进跨团队知识共享，提升团队响应能力和处理效率。
# 	•	部门公共组件建设项目：
# 	•	职责：负责跨部门公共组件的设计、开发和维护。
# 	•	技术：使用Vue.js、React和TypeScript开发可复用的UI组件库。
# 	•	描述：为公司内部多个部门构建公共组件库，提升开发效率和一致性。
# 	•	贡献：
# 	•	主导组件库的架构设计，确保组件的可扩展性和易用性。
# 	•	与设计团队紧密合作，确保组件符合UI/UX标准。
# 	•	编写详细的组件使用文档和示例，降低其他开发人员的学习成本。
# 	•	成果：
# 	•	成功上线超过50个高复用性组件，显著减少了各部门的开发时间。
# 	•	组件库被多个业务线采用，提升了产品界面的一致性和用户体验。
# 	•	项目获得公司技术部门的高度评价，并被作为内部标准推广。
# 	•	万达信息股份有限公司 软件工程师 2019.07 - 2021.05
# 	•	销售日志项目：
# 	•	职责：负责业务开发与维护。
# 	•	技术：使用Java和Spring框架开发后台服务，确保数据安全和稳定。
# 	•	描述：开发销售管理平台，支持外网填报日报和周报。
# 	•	贡献：优化日报填写和日志审批流程，提升用户使用体验。
# 	•	成果：完成日报填写、日志审批及相关统计页面开发。
# 	•	医养结合项目：
# 	•	职责：负责业务开发与维护。
# 	•	技术：使用RESTful API设计实现服务人员和机构信息模块。
# 	•	描述：为老人服务的预约平台，提供居家预约和上门服务。
# 	•	贡献：开发并优化订单派单系统，提升服务响应速度。
# 	•	成果：成功上线服务人员信息和机构信息模块。
# 	•	产品管理平台：
# 	•	职责：负责业务开发与维护。
# 	•	技术：使用Vue.js和Spring Boot构建前后端系统。
# 	•	描述：拓展人员使用范围，完善功能，与公司信息系统对接。
# 	•	贡献：实现客户管理和产品激励管理模块，提升系统协作效率。
# 	•	成果：完成客户管理和产品激励管理模块的前端及后端开发。
# 	•	自我评价
具备丰富的技术项目管理经验，能够协调项目成员，制定技术方案，规范排期，规避风险，确保项目顺利上线。具有推动业务增长的意识，与产品经理紧密合作，制定业务方案，实现价值型增长。拥有主人翁精神，主动推动业务迭代，确保项目有始有终，促进业务稳定增长。
